# Bad singly linked stack

December 2, 2025

_The journey continues_

## Last time

 - `Enum` has a "discriminant" or "tag" which is its integer value
 - size of `Enum` variants in rust: all the size of the largest one
 - **null pointer optimization**: a way that rust can avoid storing the tag for enum variants

## Previously

 - use a Workspace to put a bunch of crates in one group thing and avoid recompiling _everything_
 - `criterion` crate for benchmarking

# Cannot move a field out of a borrowed object

You may not move a field out of a borrowed object, because when the borrow ends, the object has to still be intact!


```rust
struct NotCopyable();

struct Foo {
    x: NotCopyable
}

fn thing(foo: &mut Foo) {
    let y: NotCopyable = foo.x;
}
```

It won't let me assign `foo.x` to `y` because it cannot _move_ out of `foo.x`. The fix would be if `NotCopyable` implemented `Copy` and `Clone`. For example:

```rust
#[derive(Clone)]
struct NotCopyable();
```

and then implement `clone()`; or,

```rust
#[derive(Copy,Clone)]
struct NotCopyable();
```

which will implement a trivial bitwise `clone()` for the type. Of course now it's no longer "not copyable."

Ok.

# `std::mem::replace`

If you really need to move a field out, `std::mem::replace` will pull off a heist for you, replacing the previous value with a new one, so when the borrow ends, the borrowed object is still fully intact.

```rust
fn thing(foo: &mut Foo) {
    let y = mem::replace(&mut foo.x, NotCopyable());
}
```


