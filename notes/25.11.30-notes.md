# Review time

November 30, 2025

I don't really know Rust, and I don't really remember basic computer science that well, so maybe I can try to learn basic data structures and algorithms here.

I have my old C++ book, "Data Structures and Algorithm Analysis in C++" by Mark Allen Weiss. I can try working through that and translating it into Rust.

## Repository structure

Probably doesn't make sense to put everything in one crate, since it will compile super slowly. I'm not totally sure what structure I will want to use here, but I don't want to be too rigidly tied to only using the Weiss book and I don't want to be rigidly tied to a chapter / section based organization. I'd rather have a relatively flat project structure where I can go into a subdirectory and build and run individual projects.

Dr. GPT has suggested I use workspaces, with this directory structure:

```
my-textbook/
├── Cargo.toml      # workspace
├── exercise1/
│   └── Cargo.toml
├── exercise2/
│   └── Cargo.toml
└── exercise3/
    └── Cargo.toml
```

Looks simple enough...

**Update:** I now have a workspace structure in place.

To run the individual projects, such as my `exercises/hello-world`, note that its Cargo.toml says

```toml
[package]
name = "hello-world"
```

The project name there is `hello-world`, so use `cargo run --package hello-world` to run that particular project.

## Setup

Dr. GPT has told me that `pre-commit` is actually used in Rust-only projects and so on since it's language-agnostic. I countered that I don't want to have to somehow wrangle the Python dependencies and a virtual environment in my Rust repository. GPT said most developers would just use their global pre-commit installation and document the use of this tool. So I ran `brew install pre-commit`. The point of this is to run `cargo fmt` and `cargo clippy`.

I would like to run whatever my pre-commit stuff is on CI as well.

# Algorithms time

I think everything is basically set up now. Time to start doing some algorithms. Weiss section 2.3 introduces the maximum subsequence sum problem:

> **Maximum subsequence sum problem**
>
> Given (possibly negative) integers $A_1, A_2, \dots, A_N$, find the maximum value of $\sum_{k=i}^j A_k$. (For convenience, the maximum subsequence sum is 0 if all the integers are negative.)

There are four algorithms given, so I guess my tasks are to generate sequences of integers on demand (perhaps e.g. equal numbers positive and negative) or certain fixed sequences, and try the different algorithms on them.

## Implementation

Done. Also `cargo fmt` is appeased. I also wrote very simple unit tests at the bottom. Each algorithm is working.

# Benchmarking

Supposedly `criterion` is the crate to use for benchmarking. It can do warmups and maybe measure standard deviations and things like that.