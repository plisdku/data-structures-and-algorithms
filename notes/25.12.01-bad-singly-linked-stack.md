# Bad singly linked stack

December 1, 2025

I'm going to pivot over to [too many lists](https://rust-unofficial.github.io/too-many-lists/) for a while because Weiss is immediately tossing me into implementing lists, so maybe it's time to do this linked lists torture that I keep hearing about.

## Last time

What I learned last time:
 - A _crate_ is Rust's compilation unit, which is part of why Rust seems to compile slowly compared to C++
 - A _workspace_ is a way to put a whole bunch of crates into one _thing_, and I picked a workspace to organize this repo so I can get reasonable compilation time
 - The root `Cargo.toml` defines some attributes that can be inherited by sub-crates' `Cargo.toml` files
   - `workspace.package` can be inherited
   - `workspace.dependencies` can be inherited
   - `workspace.dev-dependencies` cannot be inherited, alas
 - I can use `pre-commit` to run Rust tools like `cargo fmt` and `cargo clippy`. I'm trying it out.
 - The `criterion` crate is for benchmarking. It can make log plots of runtime, and I tried that for some simple algorithms, it's working great so far

# New project

Geez, I'm learning already.

 - Every variant in an `Enum` has the same size, so if one variant is a tuple and another one is a struct and the third is "unit-like", each variant's size is still the size of the biggest one
 - A Rust `Enum` variant has a discriminant, called the _tag_, which is an integer; and perhaps the payload

If the linked list has a single node on the stack, marked `[]`, and the rest on the heap, marked `()`, this has serious problems for splitting and merging lists:

```
[Elem A, ptr] -> (Elem B, ptr) -> (Elem C, ptr) -> (Empty, *junk*)

# Now to split this list, we have to COPY Elem C from the heap to the stack to get:

[Elem A, ptr] -> (Elem B, ptr) -> (Empty, *junk*)
[Elem C, ptr] -> (Empty, *junk*)
```

whereas if each list had just a head pointer we wouldn't need to copy any possibly huge payloads around:

```
[ptr] -> (Elem A, ptr) -> (Elem B, null)
[ptr] -> (Elem C, null)
```

## Null pointer optimization

Given that an `Enum` variant needs a discriminant and can have a payload, how do you suppose Rust implements `Option`?

```rust
enum MyOpt<T> {
  None,
  Some(T)
}
```

One possibility is that `MyOpt::None` has discriminant 0 and `MyOpt::Some(T)` has discriminant 1 and a payload, so both have size one integer plus one T. But, if `T` is a pointer type, then the payload CANNOT be zero; Rust notices the special "bit pattern" available and eliminates the tag entirely from the enum. So:
 - `MyOpt<&i32>` variants are all the size of one reference
 - `MyOpt<i32>` variants are all the size of one integer tag and one `i32` payload

The tag can supposedly be as small as one bit; the size of the variants is padded out to the next word size, a multiple of 8 bytes on my Lappy 486.


